# -*- coding: utf-8 -*-
"""
Created on Thu Jul 27 15:25:20 2017

@author: User
"""

import numpy as np
from skimage.restoration import inpaint
import random
from random import randint
import time
import os
import cv2
from skimage import color, io
from sklearn.feature_extraction.image import extract_patches_2d

#Load in Custom Functions
from dynsamp import imshow_pair, gauss_kern, padding_for_kernel, add_padding, remove_padding, distance_calc, get_samplereward 



start = time.time()
print("PreProcessing")

#Construct Image of Dimension Sc (Reshape)

sc=256

#Sample this many points randomly

#p=randint(0,6000)

p=randint(0,6000)

points=p+2000

#points=8000

#Dimensions of the Kernel 2* the Value in pixels

ksize=3

#Constant in the SD value for kernel

c=0.2

#Number of nearest measurements to keep in SD Value
L=6

#Need to define radius of z6 as a function of image area

rad=.2*sc


####Read in and Resize Image

im = color.rgb2gray(io.imread('GaN_0.bmp')) #load image and convert to greyscale

#im=np.rint(im/44)

im=im[91:91+sc, 91:91+sc] #image is 438x438, takes center of image



sz=np.shape(im)

imr=np.ravel(im) #unravael im vector


ind=imr.size #length of im

#cv2.imshow('im',im)
#Construct M Training Datasets

for m in range(0,20):
   
    #Nomenclature
    #sp=sampled points in raveled
    #spv=sampled values raveled
    #usp=unsampledpoints in raveled
    #uspv=unsampled points raveled
    
    sp=np.array(random.sample(range(ind), points))
    
    spv=imr[sp]
    
    unsbool = np.ones(ind, dtype=bool)
    
    unsbool[sp]=False
    
    usp=np.where(unsbool)
    
    
    
    
    #Construct unsampled image
    
    ims=np.zeros(ind)
    
    ims[sp]=imr[sp]
    
    
    #Inpaint Unsampled Image
    
    imsr=np.reshape(ims, sz)
    imsr=imsr*255
    imsr=imsr.astype(np.uint8)
    
    mask=np.ones(ind).astype(np.uint8)
    mask[sp]=0
    mask=np.reshape(mask, sz)
    mask=mask*255
    mask=mask.astype(np.uint8)
    
    #image_result = inpaint.inpaint_biharmonic(imsr, mask, multichannel=False)
    
    
    
    #dst = cv2.inpaint(imsr,dummat,6,cv2.INPAINT_TELEA)
    
    image_result = cv2.inpaint(imsr,mask,6,cv2.INPAINT_NS)
    
    patch_dim=3; #set patch size
    pad_dim=patch_dim-2; #set pad size
    pir=np.pad(image_result,pad_dim, 'edge') #pad image result array for patch extraction
    testpatch=(patch_dim,patch_dim) #start with smallest possible patches
    patches = extract_patches_2d(pir, testpatch)
    #start with 3x3 patches for testing
    imrr=np.ravel(image_result) 
    imrr2=np.ravel(patches)
    centpix=imrr2[4::9] #collect only center pixes of patches, start with 5th pixel then every 9 from there
    uspv=centpix[usp]
    
    uspatch=patches[usp] #collect only unsampled patches
    uspatcher=np.reshape(uspatch,(np.size(uspv),1,9)) #reshape patches into 1x9 matrices
   
    #extracts all center pixels
    
    
    #
    #plt.figure()
    #plt.imshow(image_result, interpolation='none')
    #plt.figure()
    #plt.imshow(im, interpolation='none')
    #plt.figure()
    #plt.imshow(imsr, interpolation='none')
    
    #Inpaint ims
    
    #Compute Heurestic for Reduction in Distortion
    #Create Gaussian weighting function
    #Multiply times original image at location of 
    #Measured pixel, then sum up matrix
    
    #multiply a gaussian kernel through the distortion matrix 
    #and sum
    
    
    #Also compute sigma for each entry (distance
    #between nearest measured pixle)
    
    
    

    upiu=np.array(np.unravel_index(usp, [sc,sc]))
    
    #for each entry in upiu, calculate distance to all spiu
    #and take min
    
    rr=np.shape(upiu)[2]
    
    
    end = time.time()
    print(end - start)
    
    
    updis=np.zeros(rr)
    z3=np.zeros(rr)
    z4=np.zeros(rr)
    
    start = time.time()
    print("DistanceCalc")
    
    uspv=np.reshape(uspv, [sc*sc-points, 1])
    updis, z3, z4, z6=distance_calc(rr, usp, sp, spv, uspv, rad, L, disbig, sc, points, imr)
        
    
    
    
    #Extract image patches centered on the unsampled indices
    #Multiply by gaussian kernel and average
    
    dort=(np.abs(np.reshape(imr, [sc,sc])-image_result))
    
    
    
    end = time.time()
    print(end - start)
    
    
    h=gauss_kern(ksize, np.max(updis), c)
    
    
    i_pad, j_pad = padding_for_kernel(h)
    
    
    #Upiupad is only used during training, it's the padded indices
    
    upiupad=upiu
    
    upiupad[0,:]=np.add(upiupad[0,:],i_pad)
    upiupad[1,:]=np.add(upiupad[1,:],j_pad)
    
    dortpad=add_padding(dort, h)
    #remember that you changed padding to edge type instead of constant value
    
    start = time.time()
    print("ValueCalc")
    
    
    Value=get_samplereward(upiupad, rr, updis, c, dortpad, ksize)
    
